Bibliographie
[App95]
Apple Computer Inc. Macintosh Human Interface Guidelines. Addison-wesley Publi-
shing, 1995.
[Bar88]
Marie F Barthet. Logiciels interactifs et ergonomie. Paris : Dunod Informatique, 1988.
[BCL+08]
Markus Bischof, Bettina Conradi, Peter Lachenmaier, Kai Linde, Max Meier, Philipp
Pötzl, and Elisabeth André. Xenakis : combining tangible interaction with probability-
based musical composition. In Proceedings of the 2nd international conference on
Tangible and embedded interaction, TEI ’08, pages 121–124, New York, NY, USA,
2008. ACM.
[BCW+06]
Doug A. Bowman, Jian Chen, Chadwick A. Wingrave, John F. Lucas, Andrew Ray,
Nicholas F. Polys, Qing Li, Yonca Haciahmetoglu, Ji-Sun Kim, Seonho Kim, Robert
Boehringer, and Tao Ni. New directions in 3d user interfaces. IJVR, 5(2) :3–14, 2006.
[Bec00]
Kent Beck. Extreme Programming Explained : Embrace Change. Addison-Wesley
Professional, 2000.
[Ber03]
F. Berard. The Magic Table : Computer Vision Based Augmentation of a Whiteboard
for Creative Meetings, 2003.
[Bes10]
Guillaume Besacier. Interactions post-WIMP et applications existantes sur une table
interactive. PhD thesis, UNIVERSITÉ PARIS-SUD 11, 2010.
[BRNB07]
Guillaume Besacier, Gaétan Rey, Marianne Najm, and Stéphanie Buisine. Paper Meta-
phor for Tabletop Interaction Design. In HCII’07 Human Computer Interaction Inter-
national, pages 758–767, 2007.
[BS08]
Renata Bandelloni and Carmen Santoro. Reverse Engineering Cross-Modal User In-
terfaces for Ubiquitous Environments. Work, 2008.
[BV02]
Laurent Bouillon and Jean Vanderdonckt. Retargeting Web pages to other computing
platforms with VAQUITA. Ninth Working Conference on Reverse Engineering, 2002.
Proceedings., pages 339–348, 2002.
[CCB+02]
Gaëlle Calvary, Joëlle Coutaz, Laurent Bouillon, Murielle Florins, Quentin Limbourg,
L. Marucci, Fabio Paternò, Carmen Santoro, N. Souchon, David Thevenin, and Jean
Vanderdonckt. CAMELEON Project. Technical report, CAMELEON Project, 2002.
[Cre01]
M. Crease. A Toolkit of Resource-sensitive, Multimodal Widgets. University of Glas-
gow, 2001.
[D. 06]
D. Heinemeier Hansson. World of Resource, 2006.
[Dev92]
UIMS Tool Developers. A metamodel for the runtime architecture of an interactive
system : the uims tool developers workshop. SIGCHI Bull., 24(1) :32–37, January
1992.
[DL01]
Paul Dietz and Darren Leigh. Diamondtouch : a multi-user touch technology. In Pro-
ceedings of the 14th annual ACM symposium on User interface software and techno-
logy, UIST ’01, pages 219–226, New York, NY, USA, 2001. ACM.
[FCLD12]
Paternò Fabio, Santoro Carmen, and Spano Lucio Davide. Concur Task Trees (CTT),
2012.
[Fou13]
The Eclipse Foundation. Eclipse modeling framework project (emf), 2013.
163
164
BIBLIOGRAPHIE
[FPV95]
Christelle Farenc, Philippe Palanque, and Jean Vanderdonckt. User interface evalua-
tion : is it ever usable ? Advances in Human Factors/Ergonomics, 20 :329–334, 1995.
[FvDFH90]
James D. Foley, Andries van Dam, Steven K. Feiner, and John F. Hughes. Computer
graphics : principles and practice (2nd ed.). Addison-Wesley Longman Publishing
Co., Inc., Boston, MA, USA, 1990.
[GH95]
Hans-w Gellersen and Hans-W. Gellersen. Modality Abstraction : Capturing Logical
Interaction Design as Abstraction from "User Interfaces for All". In 1st ERCIM Work-
shop on "User Inter- faces for All". ERCIM, 1995.
[GMAD05]
Derek Glover, David Miller, Doug Averis, and Victoria Door. The interactive whi-
teboard : a literature survey. Technology, Pedagogy and Education, 14(2) :155–170,
2005.
[GPF10]
André MP Grilo, Ana CR Paiva, and João Pascoal Faria. Reverse engineering of gui
models for testing. In Information Systems and Technologies (CISTI), 2010 5th Iberian
Conference on, pages 1–6. IEEE, 2010.
[GV08]
Federico Gobbo and Matteo Vaccari. The pomodoro technique for sustainable pace in
extreme programming teams. In Agile Processes in Software Engineering and Extreme
Programming, pages 180–184. Springer, 2008.
[HCT06]
P. Hutterer, B.S. Close, and B.H. Thomas. Supporting Mixed Presence Groupware in
Tabletop Applications. In First IEEE International Workshop on Horizontal Interactive
Human-Computer Systems (TABLETOP ’06), pages 63–70. IEEE, January 2006.
[IU97]
Hiroshi Ishii and Brygg Ullmer. Tangible bits. In Proceedings of the SIGCHI confe-
rence on Human factors in computing systems - CHI ’97, pages 234–241, New York,
New York, USA, March 1997. ACM Press.
[JOF11]
Cédric JOFFROY. Composition d’applications et de leurs interfaces homme-machine
dirigée par la composition fonctionnelle. PhD thesis, UNIVERSITÉ DE NICE SO-
PHIA ANTIPOLIS UFR Sciences, 2011.
[KKM03]
M. Kassoff, D. Kato, and W. Mohsin. Creating GUIs for web services. IEEE Internet
Computing, 7(5) :66–73, September 2003.
[KLL+09]
Sébastien Kubicki, Sophie Lepreux, Yoann Lebrun, Philippe Santos, Christophe
Kolski, and Jean Caelen. New human-computer interactions using tangible objects :
Application on a digital tabletop with rﬁd technology. In JulieA. Jacko, editor, Human-
Computer Interaction. Ambient, Ubiquitous and Intelligent Interaction, volume 5612
of Lecture Notes in Computer Science, pages 446–455. Springer Berlin Heidelberg,
2009.
[KODPR12]
Andre Kalawa, Occello, Anne-Marie Dery-Pinna, and Michel Riveill. Reusing user
interface across devices with different design guidelines. Knowledge and Systems En-
gineering, International Conference on, 0 :211–216, 2012.
[KP+88]
Glenn E Krasner, Stephen T Pope, et al. A description of the model-view-controller
user interface paradigm in the smalltalk-80 system. Journal of object oriented pro-
gramming, 1(3) :26–49, 1988.
[KSM99a]
L Kong, E Stroulia, and B Matichuk. Legacy interface migration : A task-centered
approach. . . . of the 8th International Conference on . . . , 1999.
[KSM99b]
Lanyan Kong, Eleni Stroulia, and Bruce Matichuk. Legacy interface migration : A
task-centered approach. In Proc. of 8 th int. conf. on Human-Computer Interaction
HCI InternationalâC™99 (Munich, pages 1167–1171, 1999.
BIBLIOGRAPHIE
165
[LL09]
Kee Yong Lim and John B Long. The MUSE method for usability engineering, vo-
lume 8. Cambridge University Press, 2009.
[Lon10]
Nguyen Hoang Long. Web Visualization of Trajectory Data using Web Open Source
Visualization Libraries Web Visualization of Trajectory Data using Web Open Source
Visualization Library.
PhD thesis, INTERNATIONAL INSTITUTE FOR GEO-
INFORMATION SCIENCE AND EARTH OBSERVATION ENSCHEDE, THE NE-
THERLANDS, 2010.
[LVMB05]
Quentin Limbourg, Jean Vanderdonckt, Benjamin Michotte, and Laurent Bouillon.
USIXML : A Language Supporting Multi-path Development of User Interfaces. In
Iﬁp International Federation For Information Processing, pages 200–220, 2005.
[McC92]
Carma McClure. The three Rs of software automation : re-engineering, repository,
reusability. Prentice-Hall, Inc., 1992.
[Mic09]
Microsoft. Microsoft Surface User Experience Guidelines, 2009.
[Mic11]
Microsoft. Microsoft Surface 2 Design and Interaction Guide. Technical Report July,
Microsoft, 2011.
[Mic12a]
Microsoft. MSDN XAML, 2012.
[Mic12b]
Microsoft WPF. WPF, 2012.
[Mic12c]
Microsoft XNA. XNA, 2012.
[Mit]
Mitsubishi Electric Research Laboratoriesb. MERL .
[MMP00]
Nikunj R. Mehta, Nenad Medvidovic, and Sandeep Phadke. Towards a taxonomy of
software connectors. In Proceedings of the 22nd international conference on Software
engineering - ICSE ’00, pages 178–187, New York, New York, USA, June 2000. ACM
Press.
[Moo95]
James D. Mooney. Portability and reusability. In Proceedings of the 1995 ACM 23rd
annual conference on Computer science - CSC ’95, pages 150–156, New York, New
York, USA, February 1995. ACM Press.
[Moo96]
Melody M Moore. Rule-based detection for reverse engineering user interfaces. In
Reverse Engineering, 1996., Proceedings of the Third Working Conference on, pages
42–48. IEEE, 1996.
[MPV11]
Gerrit Meixner, Fabio Paternò, and Jean Vanderdonckt. Past , Present , and Future of
Model-Based User Interface Development. i-com, 10 :2–11, 2011.
[MR97]
Melody Moore and Spencer Rugaber. Using knowledge representation to understand
interactive systems. In Program Comprehension, 1997. IWPC’97. Proceedings., Fifth
Iternational Workshop on, pages 60–67. IEEE, 1997.
[MVG06]
Tom Mens and Pieter Van Gorp. A taxonomy of model transformation. Electron. Notes
Theor. Comput. Sci., 152 :125–142, March 2006.
[MVL06]
José Pascual Molina Massó, Jean Vanderdonckt, and Pascual González López. Direct
manipulation of user interfaces for migration. In Proceedings of the 11th international
conference on Intelligent user interfaces - IUI ’06, page 140, New York, New York,
USA, January 2006. ACM Press.
[NC93]
Laurence Nigay and Joëlle Coutaz. A design space for multimodal systems. In Pro-
ceedings of the SIGCHI conference on Human factors in computing systems - CHI ’93,
pages 172–178, New York, New York, USA, May 1993. ACM Press.
166
BIBLIOGRAPHIE
[Nig94]
Laurence Nigay. Conception et modélisation logicielles des systèmes interactifs : ap-
plication aux interfaces multimodales. PhD thesis, UNIVERSITÉ JOSEPH FOURIER
- GRENOBLE 1, 1994.
[NM90]
Jakob Nielsen and Rolf Molich. Heuristic evaluation of user interfaces. In Proceedings
of the SIGCHI Conference on Human Factors in Computing Systems, CHI ’90, pages
249–256, New York, NY, USA, 1990. ACM.
[Pat11]
Fabio Paternn¸. Migratory interactive applications for ubiquitous environments. Sprin-
ger, 2011.
[PMM97]
Fabio Paternò, Cristiano Mancini, and Silvia Meniconi. Concurtasktrees : A diagram-
matic notation for specifying task models. In Proceedings of the IFIP TC13 Interan-
tional Conference on Human-Computer Interaction, volume 96, pages 362–369, 1997.
[PRI02]
James Patten, Ben Recht, and Hiroshi Ishii. Audiopad : a tag-based interface for musi-
cal performance. In Proceedings of the 2002 conference on New interfaces for musical
expression, NIME ’02, pages 1–6, Singapore, Singapore, 2002. National University of
Singapore.
[PSS09]
Fabio Paternò, Carmen Santoro, and Lucio Davide Spano.
MARIA : A Universal,
Declarative, Multiple Abstraction-Level Language for Service-Oriented Applications
in Ubiquitous Environments.
ACM Transactions on Computer-Human Interaction,
16(4) :1–30, November 2009.
[PZ10]
Fabio Paternò and Giuseppe Zichittella. Desktop-to-mobile web adaptation through
customizable two-dimensional semantic redesign. In Human-Centred Software Engi-
neering, pages 79–94. Springer, 2010.
[Que01]
Whitney Quesenbery. Building a Better Style Guide. In Proceedings of the Usability
Professionals Association, pages 1–10, 2001.
[RBB+95]
L Alperin Resnick, Alex Borgida, Ronald J Brachman, Deborah L McGuinness, Pe-
ter F Patel-Schneider, C Isbell, and K Zalondek. CLASSIC Description and Reference
Manual For the COMMON LISP Implementation. AI Principles Research Department,
AT&T Bell Laboratories, 1995.
[RCPsC05]
Nicolas Roussel, Olivier Chapuis, Université Paris-sud, and Orsay Cedex. Metisse :
un système de fenêtrage hautement conﬁgurable et utilisable au quotidien. In IHM
’05 : Proceedings of the 17th international conference of the Association Francophone
d’Interaction Homme-Machine, 2005.
[Res13]
Microsoft Research. NUI : Natural User Interface, 2013.
[RFJ08]
Daniel Ratiu, Martin Feilkas, and Jan Jurjens. Extracting Domain Ontologies from
Domain Speciﬁc APIs. 2008 12th European Conference on Software Maintenance and
Reengineering, 1 :203–212, 2008.
[RSP11]
Yvonne Rogers, Helen Sharp, and Jenny Preece. Interaction design : beyond human-
computer interaction. Wiley, 2011.
[SC12]
Carlos Eduardo Silva and José Creissac Campos. Can GUI Implementation Markup
Languages Be Used for Modelling ? In Human-Centered Software Engineering, pages
112–129, 2012.
[Sca86]
Dominique L. Scapin.
Guide ergonomique de conception des interfaces homme-
ordinateur.
Technical report, Institut National de Recherche en Informatique et en
Automatique, 1986.
BIBLIOGRAPHIE
167
[SVFR04]
Chia Shen, Frédéric D. Vernier, Clifton Forlines, and Meredith Ringel. DiamondSpin :
an extensible toolkit for around-the-table interaction. In Proceedings of the 2004 confe-
rence on Human factors in computing systems - CHI ’04, pages 167–174, New York,
New York, USA, April 2004. ACM Press.
[SWND03]
Dave Shreiner, Mason Woo, Jackie Neider, and Tom Davis. OpenGL programming
guide : the ofﬁcial guide to learning openGL, version 1.4. Addison-Wesley Professio-
nal, 4th ed edition, 2003.
[TC02]
David Thevenin and Joëlle Coutaz. Adaptation des IHM : Taxonomies et Archi. Logi-
cielle. In IHM 2002, pages 207–210, 2002.
[TKB78]
Andrew Tanenbaum S., Paul Klint, and Wim Bohm. Guidelines for Software Portabi-
lity. Software-Practice And Experience, 8(6) :681–698, November 1978.
[TKR10]
Thiago Tonelli, Krzysztof, and Ralf. Swing to swt and back : Patterns for api migration
by wrapping. In Proceedings of the 2010 IEEE International Conference on Software
Maintenance, ICSM ’10, pages 1–10, Washington, DC, USA, 2010. IEEE Computer
Society.
[TS99]
K. Tucker and R. E. Kurt Stirewalt. Model based user-interface reengineering.
In
Proceedings of the Sixth Working Conference on Reverse Engineering, WCRE ’99,
pages 56–, Washington, DC, USA, 1999. IEEE Computer Society.
[UI97]
Brygg Ullmer and Hiroshi Ishii. The metaDESK : Models and Prototypes for Tangible
User Interfaces. In UIST ’97 Proceedings of the 10th annual ACM symposium on User
interface software and technolog, pages 223 – 232, 1997.
[USJ+08]
Brygg Ullmer, Rajesh Sankaran, Srikanth Jandhyala, Blake Tregre, Cornelius Toole,
Karun Kallakuri, Christopher Laan, Matthew Hess, Farid Harhad, Urban Wiggins, and
Shining Sun. Tangible Menus and Interaction Trays : Core tangibles for common phy-
sical / digital activities. In TEI ’08, pages 209–212. ACM, 2008.
[Van97]
Jean Vanderdonckt. Conception assistée de la présentation d’une interface homme-
machine ergonomique pour une application de gestion hautement interactive. Doctoral
disertation. Facultés Universitaire Notre-Dame de la Paix, Namur, 1997.
[vD97]
Andries van Dam.
Post-WIMP user interfaces.
Communications of the ACM,
40(2) :63–67, February 1997.
[vdVNHF11] Bram JJ van der Vlist, Gerrit Niezen, Jun Hu, and Loe MG Feijs. Interaction pri-
mitives : Describing interaction capabilities of smart objects in ubiquitous computing
environments. In AFRICON, 2011, pages 1–6. IEEE, 2011.
[VLM+04]
Jean Vanderdonckt, Quentin Limbourg, Benjamin Michotte, Laurent Bouillon, Daniela
Trevisan, and Murielle Florins.
USIXML : a User Interface Description Language
for Specifying Multimodal User Interfaces The Reference Framework used for Multi-
Directional UI Development. Language, pages 19–20, 2004.
[W3C03]
W3C. W3C Multimodal Interaction Framework, 2003.
[WB03]
Mike Wu and Ravin Balakrishnan. Multi-ﬁnger and whole hand gestural interaction
techniques for multi-user tabletop displays. In Proceedings of the 16th annual ACM
symposium on User interface software and technology - UIST ’03, pages 193–202, New
York, New York, USA, November 2003. ACM Press.
[Weg97]
Peter Wegner. Why Interaction Is More Powerful Than Algorithms, 1997.
168
BIBLIOGRAPHIE
[WGM08]
Xin Wang, Yaser Ghanam, and Frank Maurer. From Desktop to Tabletop : Migrating
the User Interface of AgilePlanner. In Engineering Interactive Systems 2008, pages
263–270, 2008.
Appendices
169
ANNEXE A
Application des modèles de l’UI et des PI
Cette annexe a pour objectif de présenter d’abord les tableaux de correspondances pour décrire les
éléments d’une bibliothèque graphique à l’aide du modèle de type de composants graphiques présenté
au chapitre 5. Elle présente ensuite les ressources utilisées par les mécanismes d’abstraction d’une UI
ﬁnale vers les modèles d’instance. Enﬁn, cette annexe présente l’application des règles d’identiﬁcation
des PI pour les bibliothèques XAML et XAMLSurface.
A.1
Comment décrire une instance du modèle de type de composants
graphiques ?
Nous décrivons dans cette section le processus qui nous a permis d’instancier les Widgets des
bibliothèques graphiques XAML Desktop et XAML Surface pour Microsoft PixelSense. Dans l’envi-
ronnement .Net, les composants graphiques sont identiﬁés à partir des Assemblies qui appartiennent à
des DLL (Dynamic Library Link).
La classe Widget du modèle de type de composant, correspond à toutes les classes de l’Assembly
PresentationFramework pour XAML et de l’Assembly Microsoft.Surface.Presentation qui respectent
les conditions suivantes :
– les composants graphiques sont des classes publiques de l’Assembly,
– ils héritent de System.Windows.UIElement.
A.1.1
Identiﬁcation d’un Widget à partir d’un Assembly
Les attributs de la classe Widget sont identiﬁés à partir des composants graphiques identiﬁés dans
un Assembly.
– Widget.name correspond au nom du type du composant graphique : par exemple pour la
classe Microsoft.Surface.Presentation.Controls.LibraryBar de l’Assembly PresentationFrame-
work, Widget.name=’LibraryBar’.
– Widget.cardinality est déterminé à l’aide du tableau d’identiﬁcation des cardinalités (cf ta-
bleau A.2)
– Widget.contentType est déterminé à l’aide du tableau d’identiﬁcation de type de données (cf
tableau A.1)
A.1.2
Identiﬁcation des comportements
Les attributs de la classe Event des Widgets sont identiﬁés comme suit :
– l’attribut name
– l’attribut eventType est déterminé en parcourant tous les événements et les attributs d’un compo-
sant graphique et en utilisant le tableau d’identiﬁcation des types d’événements (cf tableau A.3)
– l’attribut propertyType est identiﬁé en recherchant parmi les propriétés d’un composant gra-
phique et en utilisant le tableau d’identiﬁcation des types de propriété (cf tableau A.4)
171
172
ANNEXE A. APPLICATION DES MODÈLES DE L’UI ET DES PI
DataType
XAML et XAML Surface
Boolean
Si le composant graphique implémente l’attribut Checked de type booléen
Integer
Si le composant graphique implémente l’attribut Value
String
Si le composant graphique implémente les attributs Text, Password, SelectedValue
ou la méthode AddText
Image
Si le composant graphique implémente l’attribut ImageSource
MediaElement
Si le composant graphique implémente un attribut de nom Uri
Object
Si le composant graphique implémente un attribut de nom Content
Widget
Si le composant graphique implémente un attribut de nom Children
Null
Si aucun des cas précédent n’est satisfait
TABLE A.1 – Table d’identiﬁcation de type de données du modèle
Cardinality
XAML Desktop et XAML Surface
0
Si le type de données du Widget est Null
1
Si le composant graphique implémente l’attribut Child
N
Si le composant graphique implémente la méthode AddChild
N,M
Si le composant graphique implémente les attributs Columns,Rows
TABLE A.2 – Table d’identiﬁcation des cardinalités
– l’attribut inputDeviceType est identiﬁé en utilisant le tableau d’identiﬁcation des types de pro-
priété (cf tableau A.5).
A.1.3
Remarque
Cette approche a permis d’instancier les modèles de type pour les bibliothèques graphiques
XAML Desktop pour la source et XAML Surface pour la cible.
A.2
Abstraction des UI ﬁnales
Nous présentons dans cette section les mécanismes d’abstraction d’une UI ﬁnale XAML vers le
modèle d’instance de l’UI décrit au chapitre 5.
A.2.1
Identiﬁcation des UIComponent à partir d’un ﬁchier XAML
La classe UIComponent est identiﬁée à partir d’un code source XAML en considérant toutes les
balises qui représentent les Widgets et qui ne contiennent pas d’autres balises de type Widget.
eventType
XAML Desktop et XAML Surface
Call
Si l’attribut suivant existe : AddHandler
Select
Selected, SelectedText, SelectItem
Change
AllowDrop, TextChanged, OnValueChanged, EditingMode, CanRotate,
LocationChanged, CanMove, ResizeMode, CanScal
TABLE A.3 – Table d’identiﬁcation des types de comportements
A.2. ABSTRACTION DES UI FINALES
173
propertyType
XAML Desktop et XAML Surface
Content
Si les attributs suivant existent : TextChanged, OnValueChanged,
EditingMode, Selected, SelectedText, SelectItem, Checked, AllowDrop
Size
Si les attributs suivant existent : ResizeMode, CanScale
Position
Si les attributs suivant existent LocationChanged, CanMove
Orientation
Si l’ attribut suivant existe CanRotate
WidgetStructure
Si l’ attribut suivant existe Visible
TABLE A.4 – Table d’identiﬁcation des types de propriétés
inputDeviceType
XAML Desktop et XAML Surface
DirectManipulationType
Si les événements de la souris, de l’écran tactile, du stylo
existent (MouseDown, TouchDown, ContactDown, StylusDown
, etc.)
SequantialManipulationType
Si les événements du clavier existent (Key)
Null
Si aucun événement lié à une dispositif d’entrée n’existent
TABLE A.5 – Table d’identiﬁcation des types de propriétés
Une balise est de type Widget si son nom correspond à celui d’un Widget de la bibliothèque
graphique de départ.
Les attributs de la classe container sont identiﬁées comme suit :
– id est un identiﬁant unique généré par le processus d’abstraction
– name correspond à la propriété Name de la balise relative à un composant graphique simple
– type correspond au Widget du même nom que la balise
A.2.2
Identiﬁcation des Containers à partir d’un ﬁchier XAML
La classe Container est identiﬁée à partir d’un code source XAML en considérant toutes les balises
qui représentent les Widgets et qui contiennent d’autres balises de type Widget.
Une balise est de type Widget si son nom correspond à celui d’un Widget de la bibliothèque
graphique de départ.
Les attributs de la classe container sont identiﬁés comme suit :
– id est un identiﬁant unique généré par le processus d’abstraction
– name correspond à la propriété Name de la balise relative à un container
– typeContainer est identiﬁé à partir des éléments du container
– type correspond au Widget du même nom que la balise.
A.2.3
Identiﬁcation de la classe Content à partir d’un ﬁchier XAML
La classe Content, correspond aux données graphiques d’une UI à migrer. L’attribut value cor-
respond à la valeur de la donnée graphique. Par exemple pour un bouton “Valider” en XAML, va-
lue=’Valider’ et propertyName=’Content’. L’attribut propertyName correspond au nom de la propriété
correspondante à la donnée. Pour les bibliothèques graphiques comme XAML et XAML Surface, le
tableau A.6 permet d’identiﬁer les noms de ces propriétés.
174
ANNEXE A. APPLICATION DES MODÈLES DE L’UI ET DES PI
XAML Desktop et XAML Surface
propertyName
Content, Value, Text
TABLE A.6 – Table d’identiﬁcation des propriétés de contenus
eventType
XAML Desktop et XAML Surface
Change
AllowDrop, TextChanged, OnValueChanged, EditingMode, CanRotate,
LocationChanged, CanMove, ResizeMode, CanScal
Select
Selected, SelectedText, SelectItem
Call
Si les attributs suivant existent : AddHandler
Delete
Methode Remove de la propriété Items
Update
Methode Add de la propriété Items, Méthodes AddChild, AddText de ItemsControl,
Propriétés Content, Text, DataSource,
TABLE A.7 – Table d’identiﬁcation des types de comportements
A.2.4
Identiﬁcation de la classe ImplementedEvent à partir d’un ﬁchier XAML
Les attributs de la classe Event des Widgets sont identiﬁés comme suit :
– l’attribut name correspond au nom d’un événement.
– l’attribut type est déterminé en parcourant tous les événements et les attributs d’un composant
graphique et en utilisant le tableau d’identiﬁcation des types d’événements (cf tableau A.7).
– l’attribut property est identiﬁé en recherchant parmi les propriétés d’un composant graphique
et en utilisant le tableau d’identiﬁcation des types de propriété (cf tableau A.8).
– l’attribut inputDeviceType est identiﬁé en utilisant le tableau d’identiﬁcation des types de pro-
priété (cf tableau A.9).
A.2.5
Exemple d’UIStructure XAML
Le listing A.1 décrit la structure et le positionnement des éléments de l’UI de l’application
CBA. Les «event» correspondent à l’événement Click (cf les lignes 19, 44, 47, 50 du listing A.1
par exemple).
Listing A.1 – Exemple UIStructure
<Window x:Class="ExempleApplicationTools2012.Window1"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
Title="Window1" Height="326" Width="831">
<Grid >
propertyType
XAML Desktop et XAML Surface
Content
Si les attributs suivants existent : TextChanged, OnValueChanged,
EditingMode, Selected, SelectedText, SelectItem, Checked, AllowDrop
Size
Si les attributs suivants existent : ResizeMode, CanScale
Position
Si les attributs suivants existent LocationChanged, CanMove
Orientation
Si l’attribut suivant existe CanRotate
WidgetStructure
Si l’ attribut suivant existe Visible
TABLE A.8 – Table d’identiﬁcation des types de propriétés
A.2. ABSTRACTION DES UI FINALES
175
inputDeviceType
XAML Desktop et XAML Surface
DirectManipulationType
Si les événements de la souris, de l’écran tactile, du stylo
existent (MouseDown, TouchDown, ContactDown, StylusDown,
etc.)
SequantialManipulationType
Si les événements du clavier existent (Key)
Null
Si aucun événement lié à un dispositif d’entrée n’existent
TABLE A.9 – Table d’identiﬁcation des types de propriétés
6
<Grid.RowDeﬁnitions>
<RowDeﬁnition Height="30"></RowDeﬁnition>
<RowDeﬁnition Height="258*"></RowDeﬁnition>
</Grid.RowDeﬁnitions>
<Grid.ColumnDeﬁnitions>
<ColumnDeﬁnition Width="73*"></ColumnDeﬁnition>
<ColumnDeﬁnition Width="610*"></ColumnDeﬁnition>
<ColumnDeﬁnition Width="126.03*"></ColumnDeﬁnition>
</Grid.ColumnDeﬁnitions>
<Grid Name="MenuPane" Grid.ColumnSpan="3" Grid.Row="0">
16
<Menu>
<MenuItem Header="File">
<MenuItem Header="Close" Click="Close_Click"></MenuItem>
</MenuItem>
<MenuItem Header="Edit"></MenuItem>
</Menu>
</Grid>
<Grid Name="RessourcePane" Grid.Column="0" Grid.Row="1" >
<Grid.RowDeﬁnitions>
26
<RowDeﬁnition></RowDeﬁnition>
<RowDeﬁnition></RowDeﬁnition>
<RowDeﬁnition></RowDeﬁnition>
</Grid.RowDeﬁnitions>
<Grid Name="ControlPane" Grid.Row="0" VerticalAlignment="Top">
<Grid.RowDeﬁnitions>
<RowDeﬁnition Height="20"></RowDeﬁnition>
<RowDeﬁnition Height="15"></RowDeﬁnition>
<RowDeﬁnition Height="*"></RowDeﬁnition>
</Grid.RowDeﬁnitions>
36
<Grid.ColumnDeﬁnitions>
<ColumnDeﬁnition></ColumnDeﬁnition>
<ColumnDeﬁnition></ColumnDeﬁnition>
<ColumnDeﬁnition></ColumnDeﬁnition>
<ColumnDeﬁnition></ColumnDeﬁnition>
<ColumnDeﬁnition></ColumnDeﬁnition>
</Grid.ColumnDeﬁnitions>
<Label Grid.Row="0" Grid.ColumnSpan="5" >Browser</Label>
<Button Name="ScreenShoot" Grid.Column="0" Grid.Row="1" Click="ScreenShoot_Click">
<Image Source="./Ressources/screenshot.png"></Image>
46
</Button>
<Button Name="Balloon" Grid.Column="1" Grid.Row="1" Click="Balloon_Click">
<Image Source="./Ressources/baloon1.png"></Image>
</Button>
<Button Name="Text" Grid.Column="2" Grid.Row="1" Click="Text_Click">
<Image Source="./Ressources/text1.png"></Image>
</Button>
<Button Name="Label" Grid.Column="3" Grid.Row="1">
<Image Source="./Ressources/info.png"></Image>
</Button>
56
<Button Name="Favoris" Grid.Column="4" Grid.Row="1">
<Image Source="./Ressources/info.png"></Image>
</Button>
176
ANNEXE A. APPLICATION DES MODÈLES DE L’UI ET DES PI
</Grid >
<Grid Margin="0,35,0,8" Grid.RowSpan="3">
<ListBox Name="RessourceList" Margin="0,0,0,−15" VerticalAlignment="Top" PreviewMouseLeftButtonDown="
ListBox_PreviewMouseLeftButtonDown" >
<ListBox.ContextMenu>
<ContextMenu>
<MenuItem Header="File"></MenuItem>
66
</ContextMenu>
</ListBox.ContextMenu>
</ListBox>
</Grid>
</Grid>
<Grid Grid.Column="1" Grid.Row="1" Background="DarkGray" >
<Grid.RowDeﬁnitions>
<RowDeﬁnition ></RowDeﬁnition>
<RowDeﬁnition ></RowDeﬁnition>
</Grid.RowDeﬁnitions>
76
<Grid.ColumnDeﬁnitions>
<ColumnDeﬁnition ></ColumnDeﬁnition>
<ColumnDeﬁnition ></ColumnDeﬁnition>
</Grid.ColumnDeﬁnitions>
<Canvas Name="canvas1" Grid.Column="0" Grid.Row="0" Margin="8,8,8,8" Background="White" AllowDrop="True"
Drop="Canvas_Drop" >
</Canvas>
<Canvas Name="canvas2" Grid.Column="1" Grid.Row="0" Margin="8,8,8,8" Background="White"></Canvas>
<Canvas Name="canvas3" Grid.Column="0" Grid.Row="1" Margin="8,8,8,8" Background="White"></Canvas>
<Canvas Name="canvas4" Grid.Column="1" Grid.Row="1" Margin="8,8,8,8" Background="White"></Canvas>
86
</Grid>
<Grid>
</Grid>
</Grid>
</Window>
A.2.6
Exemple de UIBehavior C#
Le listing A.2 décrit le comportement des éléments de l’UI de l’application CBA.
Listing A.2 – Exemple UIBehavior
namespace ExempleApplicationTools2012
{
/// <summary>
/// Logique d’interaction pour Window1.xaml
/// </summary>
public partial class Window1 : Window
7
{
public Window1()
{
InitializeComponent();
_controler = new Controler.Controler();
canc = new CanvasClass(this.canvas1, this.canvas2, this.canvas3, this.canvas4);
_controler._view.RessourceList = RessourceList;
}
private CanvasClass canc = null;
private Controler.Controler _controler;
17
private void ListBox_DragLeave(object sender, DragEventArgs e)
{ }
private void Canvas_Drop(object sender, DragEventArgs e)
{
Canvas parent = (Canvas)sender;
_controler.DropCanvas(parent);
}
private void ListBox_DragEnter(object sender, DragEventArgs e)
A.2. ABSTRACTION DES UI FINALES
177
{ }
private void ListBox_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
27
{
ListBox parent = (ListBox)sender;
_controler.DragOutList(parent, e.GetPosition((ListBox)parent));
}
private void Text_Click(object sender, RoutedEventArgs e)
{
_controler.getItemList("text");
}
private void Balloon_Click(object sender, RoutedEventArgs e)
37
{
_controler.getItemList("ballon");
}
}
}
A.2.7
Exemple d’AbstractView C#
Le listing A.3 décrit une vue abstraite de l’application CBA. La méthode updateRessourceList (cf
ligne 7 du listing A.3) représente les ﬂèches de type «updateView» pour les interactions en sortie car
elle permet une notiﬁcation de la vue par le modèle ou le contrôleur.
Listing A.3 – Exemple AbstractView
using System;
namespace ComicBook.View
{
interface IAView
{
void canvas_Drop(object parent);
void dragOutList(object parent, System.Windows.Point position);
void updateRessourceList(System.Collections.ObjectModel.ObservableCollection<System.Windows.Controls.Image> coll);
9
}
}
Le listing A.4 est une implémentation de la vue abstraite selon les éléments de la bibliothèque gra-
phique. Cette classe est modiﬁée pendant la migration car elle n’est pas indépendante des instruments
d’interactions.
Listing A.4 – Exemple implémentation d’AbstractView
namespace ComicBook.View
{
public class AView : ComicBook.View.IAView
{
//store the "source" listbox
Object data = null;
CanvasClass canc = null;
public ListBox RessourceList;
public AView()
10
{ }
public void canvas_Drop(Object parent)
{
if (data != null)
canc.addBallon((Canvas)parent, (UIElement)data);
}
public void updateRessourceList (ObservableCollection<Image> coll)
{
RessourceList.ItemsSource = coll;
}
20
public void dragOutList(Object parent,Point position)
{
178
ANNEXE A. APPLICATION DES MODÈLES DE L’UI ET DES PI
//get the object source for the selected item
object data1 = GetObjectDataFromPoint((ListBox)parent, position);
//if the data is not null then start the drag drop operation
if (data1 != null)
{
data = data1;
DragDrop.DoDragDrop((ListBox)parent, data1, DragDropEffects.Copy);
30
}
}
private static object GetObjectDataFromPoint(ListBox source, Point point)
{
UIElement element = source.InputHitTest(point) as UIElement;
if (element != null)
{
//get the object from the element
object data = DependencyProperty.UnsetValue;
while (data == DependencyProperty.UnsetValue)
40
{
// try to get the object value for the corresponding element
data = source.ItemContainerGenerator.ItemFromContainer(element);
if (data == DependencyProperty.UnsetValue)
element = VisualTreeHelper.GetParent(element) as UIElement;
if (element == source)
return null;
}
if (data != DependencyProperty.UnsetValue)
return data;
50
}
return null;
}
}
}
A.2. ABSTRACTION DES UI FINALES
179
180
ANNEXE A. APPLICATION DES MODÈLES DE L’UI ET DES PI
A.3
Primitives d’interactions
A.3.1
Liste des Widgets
A.3. PRIMITIVES D’INTERACTIONS
181
182
ANNEXE A. APPLICATION DES MODÈLES DE L’UI ET DES PI
Table des ﬁgures
2.1
Applications sur les marchés de téléchargement . . . . . . . . . . . . . . . . . . . .
10
2.2
Description de la fenêtre principale de l’application CBA . . . . . . . . . . . . . . .
11
2.3
Migration de la structure d’une UI pour desktop sur une table interactive . . . . . . .
14
2.4
Espace problèmes de la migration des UI vers les tables interactives
. . . . . . . . .
16
3.1
Modèle d’interactions instrumentale d’une table interactive . . . . . . . . . . . . . .
24
3.2
Table interactive DiamondTouch . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
3.3
Instanciation physique des éléments GUI dans TUI . . . . . . . . . . . . . . . . . .
26
3.4
Instances des containers DiamondSpin . . . . . . . . . . . . . . . . . . . . . . . . .
28
3.5
Exemple de ScatterView
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
3.6
Modèle d’interactions abstraites de Gellersen
. . . . . . . . . . . . . . . . . . . . .
32
3.7
Illustration de la propriété 360˚ . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
3.8
Représentation synthétique des guidelines selon les trois dimensions des UI . . . . .
40
3.9
Représentation synthétique des guidelines suivant deux dimensions . . . . . . . . . .
42
4.1
Application de consultation des contacts . . . . . . . . . . . . . . . . . . . . . . . .
48
4.2
Synthèse de la migration manuelle des UI . . . . . . . . . . . . . . . . . . . . . . .
48
4.3
Synthèse des approches de portage des UI sur tables interactives . . . . . . . . . . .
52
4.4
Exemple de transformation USIXML
. . . . . . . . . . . . . . . . . . . . . . . . .
54
4.5
Service de migration des UI
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
4.6
Synthèse des approches automatiques de migration des UI
. . . . . . . . . . . . . .
57
4.7
Processus de migration avec MORPH . . . . . . . . . . . . . . . . . . . . . . . . .
58
4.8
Synthèse de l’approche semi automatique
. . . . . . . . . . . . . . . . . . . . . . .
62
4.9
Synthèse des approches de migration des UI . . . . . . . . . . . . . . . . . . . . . .
63
5.1
Un artéfact d’une UI
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
5.2
Boîte de dialogue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
5.3
Types et instances de composants graphiques
. . . . . . . . . . . . . . . . . . . . .
74
5.4
Modèle de types de composants graphiques
. . . . . . . . . . . . . . . . . . . . . .
76
5.5
Modèle de structure d’instance d’une UI . . . . . . . . . . . . . . . . . . . . . . . .
82
5.6
Illustration des types de container
. . . . . . . . . . . . . . . . . . . . . . . . . . .
85
5.7
Modèle abstrait et UI ﬁnale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
6.1
Processus de migration assistée . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
100
6.2
Critères ergonomiques de conception et guidelines pour favoriser la collaboration . .
102
6.3
Critères ergonomiques de conception et guidelines pour des UI tangibles . . . . . . .
103
6.4
Utilisations effectives des guidelines par les mécanismes de migration des UI
. . . .
104
6.5
Modèle de règles de substitution . . . . . . . . . . . . . . . . . . . . . . . . . . . .
105
6.6
Modèle de règles de concrétisation . . . . . . . . . . . . . . . . . . . . . . . . . . .
106
6.7
Exemple des groupes d’éléments graphiques à transformer
. . . . . . . . . . . . . .
110
6.8
Exemple de ControlGroup
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
112
6.9
Exemple de ControlGroup sur table interactive Micorsoft PixelSense . . . . . . . . .
112
6.10 Exemple de DisplayGroup
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
6.11 Exemple de DisplayGroup migré sur une table interactive . . . . . . . . . . . . . . .
115
183
184
TABLE DES FIGURES
6.12 Illustration d’un UpdateGroup . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
6.13 Exemple d’un UpdateGroup sur une table interactive
. . . . . . . . . . . . . . . . .
117
6.14 Représentation de l’UI CBA pour tables interactives . . . . . . . . . . . . . . . . . .
118
6.15 Modèle UI CBA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
130
7.1
Processus semi automatique de migration d’une UI vers les tables interactives . . . .
138
7.2
Architecture des applications migrées vers les tables interactives . . . . . . . . . . .
139
7.3
Exemple de cadre de sélection des éléments graphique dans l’éditeur du prototype . .
146
7.4
Exemple de substitution de LibraryBar par SurfaceListBox . . . . . . . . . . . . . .
147
7.5
Menu d’association d’un tag avec un container . . . . . . . . . . . . . . . . . . . . .
147
7.6
Éditeur graphique du prototype . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
148
7.7
Fiche d’évaluation de la migration des applications
. . . . . . . . . . . . . . . . . .
151
7.8
Application agenda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
151
7.9
Regroupement des éléments de l’application Album Photo
. . . . . . . . . . . . . .
152
7.10 Regroupement des éléments de l’application de dessin
. . . . . . . . . . . . . . . .
153
7.11 Regroupement des éléments de l’application de calculatrice . . . . . . . . . . . . . .
154
7.12 Synthèse de l’étude de la migration des quatre applications . . . . . . . . . . . . . .
155
Liste des tableaux
3.1
Synthèse des dispositifs physiques d’interactions pour 3 tables interactives . . . . . .
27
3.2
Type d’UI pour les tables interactives
. . . . . . . . . . . . . . . . . . . . . . . . .
35
3.3
Afﬁnement des critères ergonomiques de Scapin . . . . . . . . . . . . . . . . . . . .
37
3.4
Migration de l’aspect visuel d’un formulaire . . . . . . . . . . . . . . . . . . . . . .
42
4.1
Synthèse des technologies de portage des UI sur tables interactives . . . . . . . . . .
51
4.2
Table d’équivalences
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
4.3
Récapitulatif de MORPH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
5.1
Exemples de primitives d’interactions en entrée . . . . . . . . . . . . . . . . . . . .
72
5.2
Exemple de primitives d’interactions en sortie . . . . . . . . . . . . . . . . . . . . .
74
5.3
Types de container
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
6.1
Caractéristiques des ControlGroups
. . . . . . . . . . . . . . . . . . . . . . . . . .
110
6.2
Règle de substitution des groupes de contrôle
. . . . . . . . . . . . . . . . . . . . .
111
6.3
Règle de concrétisation des groupes de contrôle . . . . . . . . . . . . . . . . . . . .
111
6.4
Caractéristiques des groupes d’afﬁchage de contenus
. . . . . . . . . . . . . . . . .
113
6.5
Règle de substitution des groupes DisplayGroups . . . . . . . . . . . . . . . . . . .
114
6.6
Caractéristiques des groupes de modiﬁcation de contenus . . . . . . . . . . . . . . .
115
6.7
Règle de substitution des UpdateGroups . . . . . . . . . . . . . . . . . . . . . . . .
116
6.8
Caractéristiques des groupes mixtes
. . . . . . . . . . . . . . . . . . . . . . . . . .
117
6.9
Synthèse des problèmes traités par les transformations des groupes . . . . . . . . . .
120
6.10 Caractéristiques des interacteurs de données en sortie . . . . . . . . . . . . . . . . .
121
6.11 Caractéristiques des interacteurs de données en entrée et en sortie
. . . . . . . . . .
122
6.12 Caractéristiques des interacteurs d’activation
. . . . . . . . . . . . . . . . . . . . .
122
6.13 Synthèse des problèmes traités par les transformations des interacteurs . . . . . . . .
123
6.14 Poids des PI par rapport aux guidelines . . . . . . . . . . . . . . . . . . . . . . . . .
126
6.15 Poids des types de données par rapport aux guidelines . . . . . . . . . . . . . . . . .
127
6.16 Coût des interventions manuelles . . . . . . . . . . . . . . . . . . . . . . . . . . . .
129
6.17 Widgets équivalents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
A.1
Table d’identiﬁcation de type de données du modèle . . . . . . . . . . . . . . . . . .
172
A.2
Table d’identiﬁcation des cardinalités
. . . . . . . . . . . . . . . . . . . . . . . . .
172
A.3
Table d’identiﬁcation des types de comportements . . . . . . . . . . . . . . . . . . .
172
A.4
Table d’identiﬁcation des types de propriétés . . . . . . . . . . . . . . . . . . . . . .
173
A.5
Table d’identiﬁcation des types de propriétés . . . . . . . . . . . . . . . . . . . . . .
173
A.6
Table d’identiﬁcation des propriétés de contenus . . . . . . . . . . . . . . . . . . . .
174
A.7
Table d’identiﬁcation des types de comportements . . . . . . . . . . . . . . . . . . .
174
A.8
Table d’identiﬁcation des types de propriétés . . . . . . . . . . . . . . . . . . . . . .
174
A.9
Table d’identiﬁcation des types de propriétés . . . . . . . . . . . . . . . . . . . . . .
175
185
186
LISTE DES TABLEAUX
Résumé
Dans le domaine du génie logiciel pour les Interactions Homme Machine (IHM), la migration des interfaces
utilisateurs (UI) est un moyen pour réutiliser des applications sur des plateformes ayant des modalités d’inter-
actions différentes des environnements de départ. Les approches existantes de migration des UI sont manuelles
dans le cadre des approches spéciﬁques, elles sont automatiques dans le cadre des services d’adaptation des UI
aux contextes d’usage, ou elles sont semi automatiques dans le cadre d’une migration ﬂexible dirigée par un
concepteur.
Dans cette thèse nous nous intéressons à la migration semi automatique des UI vers une cible comme une
table interactive dans l’objectif de transformer des UI Desktop en UI qui favorisent la collaboration et l’utili-
sation des objets tangibles. Les tables interactives sont des plateformes qui disposent des instruments d’inter-
actions permettant de décrire des UI tangibles et multi-utilisateurs. En considérant que le noyau fonctionnel
(NF) des applications de départ peut être réutilisés sur les cibles sans changement, les UI des applications sont
caractérisées par la dimension des dialogues entre les utilisateurs et le système, la dimension de la structure et
du positionnement des éléments graphiques et la dimension du style des éléments visuels. La migration d’une
UI dans ces conditions consiste à transformer ou à recréer les différentes dimensions d’une UI de départ pour
la cible tout en considérant les critères de conception des UI pour les tables interactives.
Nous proposons dans cette thèse un modèle d’interactions abstraites pour établir les équivalences entre les
dialogues et la structure des UI indépendamment des modalités d’interactions des plateformes source et cible.
Les primitives d’interactions et la structure des composants graphiques permettent de décrire des opérateurs
d’équivalences pour retrouver et classer les éléments graphiques équivalents en prenant en compte les guide-
lines des tables interactives. Nous proposons aussi des règles de substitution et de concrétisation pour accroître
l’accessibilité des éléments graphiques et favoriser l’utilisation des objets tangibles.
Mots clés :
migration des interfaces utilisateurs, équivalences des plateformes, modalités d’interactions,
critères de conception, guidelines
Abstract
In software engineering, in the ﬁeld of human computer interaction (HCI), the migration of user interface
(UI) is a way to reuse existing applications on platforms with different interactions modalities. The existing
approaches for UI migration can be manual (for speciﬁc applications), they can be automatic (for services
which adapt UI based on context aware), or they can be mix of the previous - semi automatic (providing a
ﬂexible migration process driven by the person in charge).
This thesis proposes a semi automatic process for migration of UI from a desktop to interactive table for the
purpose of transforming the UI of desktop to support further collaboration and usage of tangible objects. The
interactive tables are platforms with interactions instruments which allow the describtion of tangible and multi
users UIs. Considering that the functional core (FC) of source applications can be reused on target platform
without transformation, any UI can be characterized with three dimensions : the ﬁrst dimension concerns the
dialogues between the users and the system, the second dimension concerns the structure and the layout of
graphical components, and the third dimension concerns the visual style of graphical elements. In this context,
the problematic regarding the UI migration is how to transform or re inject these different dimensions of source
UI into the target, while considering the UI design criteria for interactive tables.
This thesis proposes an abstract interactions model for establishing equivalences (independent of modalities
of interactions) between the source and the dialogue and structure of the target. The primitives of interaction and
the structure of graphical components are used to describe equivalence operators to ﬁnd and to rank equivalent
elements on interactive tables. Furthermore, this thesis proposes substitution and concretization rules to increase
the accessibility of graphical elements and to facilitate the usage of tangible objects. The ranking process and
the transformation rules are based on guidelines for UI migration to interactive tables which are interpreted
form design criteria.
Keywords :
user interface migration, équivalence of plateform, design criteria, guidelines
